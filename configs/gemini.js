import { GoogleGenerativeAI } from "@google/generative-ai"

const apiKey = process.env.NEXT_PUBLIC_GEMINI_API_KEY
const genAI = new GoogleGenerativeAI(apiKey)

const model = genAI.getGenerativeModel({
  model: "gemini-2.0-flash",
});

const generationConfig = {
  temperature: 1,
  topP: 0.95,
  topK: 40,
  maxOutputTokens: 8192,
  responseMimeType: "application/json",
};

export const createCourse = model.startChat({
  generationConfig,
  history: [
    {
      role: "user",
      parts: [
        { text: "Generate comprehensive study material on java oops tailored for coding at a medium difficulty. The output should include:\n\nA concise course summary.\nA structured list of chapters, each with a brief chapter summary.\nFor each chapter, a detailed topic list formatted in JSON.\nEnsure the material is clear, logically organized, and appropriate for the specified course type and difficulty level." },
      ],
    },
    {
      role: "model",
      parts: [
        { text: "```json\n{\n  \"courseTitle\": \"Intermediate Java Object-Oriented Programming\",\n  \"courseSummary\": \"This course builds upon the foundations of Java programming and delves into the core principles of Object-Oriented Programming (OOP).  It covers essential OOP concepts like encapsulation, inheritance, polymorphism, and abstraction, along with design principles, exception handling, and working with interfaces and abstract classes. This course aims to equip you with the skills to design, implement, and maintain robust and scalable Java applications using OOP best practices.  Emphasis will be placed on practical application through coding examples and exercises suitable for intermediate-level learners.\",\n  \"chapters\": [\n    {\n      \"chapterNumber\": 1,\n      \"chapterTitle\": \"Introduction to Object-Oriented Programming (OOP)\",\n      \"chapterSummary\": \"This chapter revisits the fundamentals of OOP and its benefits. It introduces the core concepts of classes, objects, encapsulation, and basic class design in Java. It emphasizes the advantages of using OOP for code organization, reusability, and maintainability.\",\n      \"topics\": [\n        {\n          \"topicTitle\": \"Review of Fundamental Concepts\",\n          \"subtopics\": [\n            \"What is Object-Oriented Programming?\",\n            \"Procedural vs. Object-Oriented Approach\",\n            \"Advantages of OOP (Modularity, Reusability, Maintainability)\"\n          ]\n        },\n        {\n          \"topicTitle\": \"Classes and Objects\",\n          \"subtopics\": [\n            \"Definition of a Class\",\n            \"Creating Objects from Classes\",\n            \"Object State (Attributes/Fields)\",\n            \"Object Behavior (Methods)\",\n            \"Constructors: Purpose and Types (Default, Parameterized)\"\n          ]\n        },\n        {\n          \"topicTitle\": \"Encapsulation: Hiding Data and Implementation Details\",\n          \"subtopics\": [\n            \"Access Modifiers: `public`, `private`, `protected`, `default` (package-private)\",\n            \"Using Access Modifiers for Data Hiding\",\n            \"Getters and Setters (Accessor and Mutator Methods)\",\n            \"Benefits of Encapsulation (Data Integrity, Code Flexibility)\"\n          ]\n        },\n        {\n          \"topicTitle\": \"Basic Class Design Principles\",\n          \"subtopics\": [\n            \"Identifying Classes and Objects in a Problem Domain\",\n            \"Defining Attributes and Methods for Classes\",\n            \"Proper Naming Conventions for Classes, Methods, and Variables\",\n            \"Writing Clean and Readable Code\"\n          ]\n        },\n         {\n          \"topicTitle\": \"Practical Example: Designing a `BankAccount` Class\",\n          \"subtopics\": [\n            \"Defining attributes like `accountNumber`, `balance`, `accountHolderName`\",\n            \"Defining methods like `deposit`, `withdraw`, `getBalance`\",\n            \"Implementing basic error handling for insufficient funds\"\n          ]\n        }\n      ]\n    },\n    {\n      \"chapterNumber\": 2,\n      \"chapterTitle\": \"Inheritance: Extending Class Functionality\",\n      \"chapterSummary\": \"This chapter explores inheritance, a powerful mechanism for creating new classes based on existing ones. It covers single inheritance, hierarchical inheritance, method overriding, and the use of the `super` keyword.\",\n      \"topics\": [\n        {\n          \"topicTitle\": \"Introduction to Inheritance\",\n          \"subtopics\": [\n            \"What is Inheritance?\",\n            \"The 'is-a' Relationship\",\n            \"Parent Class (Superclass) and Child Class (Subclass)\",\n            \"Benefits of Inheritance (Code Reusability, Extensibility)\"\n          ]\n        },\n        {\n          \"topicTitle\": \"Types of Inheritance (in Java)\",\n          \"subtopics\": [\n            \"Single Inheritance\",\n            \"Multilevel Inheritance\",\n            \"Hierarchical Inheritance\",\n            \"Multiple Inheritance (through Interfaces - covered in a later chapter)\"\n          ]\n        },\n        {\n          \"topicTitle\": \"Method Overriding\",\n          \"subtopics\": [\n            \"What is Method Overriding?\",\n            \"Overriding Methods in Subclasses\",\n            \"@Override Annotation\",\n            \"Rules for Method Overriding (Same Signature, Compatible Return Type, Access Modifiers)\",\n            \"Importance of the `@Override` Annotation\"\n          ]\n        },\n        {\n          \"topicTitle\": \"The `super` Keyword\",\n          \"subtopics\": [\n            \"Using `super` to Access Parent Class Members\",\n            \"Calling Parent Class Constructors using `super()`\",\n            \"Accessing Overridden Methods using `super`\"\n          ]\n        },\n        {\n          \"topicTitle\": \"Practical Example: Extending a `Vehicle` Class\",\n          \"subtopics\": [\n            \"Creating a `Vehicle` class with attributes like `model`, `make`, and `speed`\",\n            \"Creating subclasses like `Car` and `Bike` that inherit from `Vehicle`\",\n            \"Overriding the `accelerate` method in `Car` and `Bike`\",\n            \"Using `super` to call the parent class's `accelerate` method\"\n          ]\n        }\n      ]\n    },\n    {\n      \"chapterNumber\": 3,\n      \"chapterTitle\": \"Polymorphism: One Interface, Multiple Implementations\",\n      \"chapterSummary\": \"This chapter introduces polymorphism, the ability of an object to take on many forms. It covers both compile-time (static) polymorphism through method overloading and runtime (dynamic) polymorphism through method overriding and interfaces.\",\n      \"topics\": [\n        {\n          \"topicTitle\": \"Introduction to Polymorphism\",\n          \"subtopics\": [\n            \"What is Polymorphism?\",\n            \"The 'one interface, multiple implementations' concept\",\n            \"Compile-time Polymorphism (Static Binding)\",\n            \"Runtime Polymorphism (Dynamic Binding)\"\n          ]\n        },\n        {\n          \"topicTitle\": \"Compile-time Polymorphism: Method Overloading\",\n          \"subtopics\": [\n            \"What is Method Overloading?\",\n            \"Overloading Methods with Different Parameters (Number, Type, Order)\",\n            \"How the Compiler Resolves Overloaded Methods\"\n          ]\n        },\n        {\n          \"topicTitle\": \"Runtime Polymorphism: Method Overriding (Revisited)\",\n          \"subtopics\": [\n            \"How Method Overriding Enables Runtime Polymorphism\",\n            \"Using Parent Class References to Refer to Subclass Objects\",\n            \"The `instanceof` Operator (and its limitations)\",\n            \"Dynamic Method Dispatch\"\n          ]\n        },\n        {\n          \"topicTitle\": \"Abstract Classes and Methods\",\n          \"subtopics\": [\n            \"What are Abstract Classes?\",\n            \"Why Use Abstract Classes?\",\n            \"Abstract Methods (Methods without Implementation)\",\n            \"Rules for Abstract Classes and Methods\",\n            \"Concrete Classes: Implementing Abstract Methods\",\n            \"When to use Abstract Classes vs. Concrete Classes\"\n          ]\n        },\n        {\n          \"topicTitle\": \"Practical Example: Shape Hierarchy with Polymorphism\",\n          \"subtopics\": [\n            \"Creating an abstract `Shape` class with an abstract `calculateArea()` method\",\n            \"Creating subclasses like `Circle`, `Rectangle`, and `Triangle` that extend `Shape`\",\n            \"Implementing the `calculateArea()` method in each subclass\",\n            \"Using a `Shape` array to store objects of different shape types and calculating their areas\"\n          ]\n        }\n      ]\n    },\n    {\n      \"chapterNumber\": 4,\n      \"chapterTitle\": \"Abstraction: Hiding Complexity\",\n      \"chapterSummary\": \"This chapter focuses on abstraction, the process of simplifying complex systems by modeling classes based on essential characteristics, hiding unnecessary details from the user.  It covers abstract classes, interfaces, and the differences between them.\",\n      \"topics\": [\n        {\n          \"topicTitle\": \"Introduction to Abstraction\",\n          \"subtopics\": [\n            \"What is Abstraction?\",\n            \"Hiding Complexity and Showing Essential Details\",\n            \"Levels of Abstraction\",\n            \"Importance of Abstraction in Software Design\"\n          ]\n        },\n        {\n          \"topicTitle\": \"Abstract Classes (Detailed)\",\n          \"subtopics\": [\n            \"Review: Abstract Classes and Methods\",\n            \"The Purpose of Abstract Classes\",\n            \"Restrictions on Abstract Classes\",\n            \"Differences Between Abstract Classes and Concrete Classes\",\n            \"Examples: Use cases where abstract classes are appropriate\"\n          ]\n        },\n        {\n          \"topicTitle\": \"Interfaces\",\n          \"subtopics\": [\n            \"What are Interfaces?\",\n            \"Defining Interfaces\",\n            \"Implementing Interfaces\",\n            \"Multiple Inheritance Through Interfaces (Achieving Multiple Inheritance in Java)\",\n            \"Constants in Interfaces\",\n            \"Default Methods in Interfaces (Java 8 and later)\",\n            \"Static Methods in Interfaces (Java 8 and later)\",\n            \"Functional Interfaces and Lambda Expressions (Introduction – to be covered in more depth later)\",\n            \"Marker Interfaces\"\n          ]\n        },\n        {\n          \"topicTitle\": \"Abstract Classes vs. Interfaces: Choosing the Right Approach\",\n          \"subtopics\": [\n            \"When to Use Abstract Classes?\",\n            \"When to Use Interfaces?\",\n            \"Key Differences in Implementation and Use\",\n            \"Considerations for Code Design and Maintainability\"\n          ]\n        },\n        {\n          \"topicTitle\": \"Practical Example: Implementing a `Flyable` Interface\",\n          \"subtopics\": [\n            \"Creating a `Flyable` interface with a `fly()` method\",\n            \"Implementing the `Flyable` interface in classes like `Airplane` and `Bird`\",\n            \"Demonstrating the use of the `Flyable` interface to work with different flying objects in a generic way\"\n          ]\n        }\n      ]\n    },\n    {\n      \"chapterNumber\": 5,\n      \"chapterTitle\": \"Exception Handling\",\n      \"chapterSummary\": \"This chapter teaches how to handle runtime errors (exceptions) gracefully in Java. It covers the `try-catch-finally` block, different types of exceptions, and creating custom exceptions.\",\n      \"topics\": [\n        {\n          \"topicTitle\": \"Introduction to Exception Handling\",\n          \"subtopics\": [\n            \"What are Exceptions?\",\n            \"Types of Errors: Compile-time Errors vs. Runtime Errors\",\n            \"The Importance of Exception Handling\",\n            \"Graceful Error Handling and Program Stability\"\n          ]\n        },\n        {\n          \"topicTitle\": \"The `try-catch-finally` Block\",\n          \"subtopics\": [\n            \"The `try` Block: Enclosing Code That Might Throw an Exception\",\n            \"The `catch` Block: Handling Specific Exceptions\",\n            \"The `finally` Block: Executing Code Regardless of Exception Outcome\",\n            \"Multiple `catch` Blocks (Handling Different Exception Types)\",\n            \"Nested `try-catch` Blocks\"\n          ]\n        },\n        {\n          \"topicTitle\": \"Types of Exceptions\",\n          \"subtopics\": [\n            \"Checked Exceptions (Compile-time Exceptions)\",\n            \"Unchecked Exceptions (Runtime Exceptions)\",\n            \"Error Exceptions (System Errors)\"\n          ]\n        },\n        {\n          \"topicTitle\": \"Exception Hierarchy\",\n          \"subtopics\": [\n            \"The `Throwable` Class\",\n            \"The `Exception` Class\",\n            \"The `RuntimeException` Class\",\n            \"Common Exception Classes (e.g., `IOException`, `NullPointerException`, `ArithmeticException`)\",\n            \"Understanding the inheritance relationships within the exception hierarchy\"\n          ]\n        },\n        {\n          \"topicTitle\": \"Throwing Exceptions\",\n          \"subtopics\": [\n            \"The `throw` Keyword\",\n            \"Creating and Throwing Custom Exceptions\"\n          ]\n        },\n        {\n          \"topicTitle\": \"Custom Exceptions\",\n          \"subtopics\": [\n            \"Creating Custom Exception Classes\",\n            \"Extending the `Exception` or `RuntimeException` Class\",\n            \"Providing Custom Error Messages\",\n            \"Use cases when creating custom exceptions is beneficial\"\n          ]\n        },\n        {\n          \"topicTitle\": \"The `throws` Clause\",\n          \"subtopics\": [\n            \"Declaring Exceptions that a Method Might Throw\",\n            \"Using the `throws` Clause in Method Signatures\",\n            \"Relationship between `throw` and `throws`\"\n          ]\n        },\n        {\n          \"topicTitle\": \"Practical Example: Handling File Input/Output Exceptions\",\n          \"subtopics\": [\n            \"Reading from a file using `FileReader` and `BufferedReader`\",\n            \"Handling `IOException` when the file does not exist or cannot be read\",\n            \"Using `finally` to ensure that resources (e.g., file streams) are closed properly\",\n            \"Implementing custom exception for specific file-related errors\"\n          ]\n        }\n      ]\n    },\n    {\n      \"chapterNumber\": 6,\n      \"chapterTitle\": \"Object-Oriented Design Principles\",\n      \"chapterSummary\": \"This chapter introduces several key Object-Oriented Design (OOD) principles, including SOLID principles, to help create maintainable, flexible, and robust software. It demonstrates how to apply these principles in Java code.\",\n      \"topics\": [\n        {\n          \"topicTitle\": \"Introduction to Object-Oriented Design Principles\",\n          \"subtopics\": [\n            \"What are Object-Oriented Design Principles?\",\n            \"Why are OOD Principles Important?\",\n            \"Benefits of Following OOD Principles (Maintainability, Reusability, Scalability)\",\n            \"Overview of Common OOD Principles\"\n          ]\n        },\n        {\n          \"topicTitle\": \"SOLID Principles (Detailed Explanation with Java Examples)\",\n          \"subtopics\": [\n            \"Single Responsibility Principle (SRP): A class should have only one reason to change.\",\n            \"Open/Closed Principle (OCP): Software entities should be open for extension but closed for modification.\",\n            \"Liskov Substitution Principle (LSP): Subtypes must be substitutable for their base types.\",\n            \"Interface Segregation Principle (ISP): Clients should not be forced to depend on methods they do not use.\",\n            \"Dependency Inversion Principle (DIP): Depend upon Abstractions. Do not depend upon concretions.\"\n          ]\n        },\n        {\n          \"topicTitle\": \"Other Important OOD Principles\",\n          \"subtopics\": [\n            \"DRY (Don't Repeat Yourself): Avoid code duplication.\",\n            \"KISS (Keep It Simple, Stupid): Strive for simplicity in design and implementation.\",\n            \"YAGNI (You Ain't Gonna Need It): Don't add functionality until it's actually needed.\",\n             \"Law of Demeter (LoD): An object should talk only to its immediate neighbors\"\n          ]\n        },\n        {\n          \"topicTitle\": \"Applying OOD Principles in Java Code\",\n          \"subtopics\": [\n            \"Refactoring Code to Adhere to SOLID Principles\",\n            \"Using Abstract Classes and Interfaces to Promote Abstraction and Decoupling\",\n            \"Writing Unit Tests to Verify Design Correctness\",\n            \"Practical examples demonstrating the application of each principle.\"\n          ]\n        },\n        {\n          \"topicTitle\": \"Practical Example: Refactoring a poorly designed class using SOLID principles\",\n          \"subtopics\": [\n            \"Start with a class violating multiple SOLID principles\",\n            \"Identify the violations\",\n            \"Step-by-step refactoring to adhere to each principle\",\n            \"Demonstrate the improved maintainability and testability of the refactored code\"\n          ]\n        }\n      ]\n    }\n  ]\n}\n```" },
      ],
    },
  ],
})

